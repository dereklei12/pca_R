---
title: "R Notebook"
output: pdf_document
---

```{r setup, message=FALSE, warning=FALSE}
set.seed(2025)
suppressPackageStartupMessages({
  library(ggplot2)
  library(dplyr)
  library(tidyr)
  library(knitr)
})
# Need：mixOmics / rARPACK / RSpectra / bench
have_bench <- requireNamespace("bench", quietly = TRUE)
have_mixOmics <- requireNamespace("mixOmics", quietly = TRUE)
```

# Data

```{r}
data = readRDS(file = 'Data/HaffinaCovidPBMC_30000cells_dense.rds')
data = t(data)
dim(data)

# Subset the data to a specified size
ncell = 2000          # choose number of cells, do not go above 2000
ngene = 5000          # choose the number of genes, do not go above 5000

set.seed(2021)
index.cell = sample(rownames(data), replace = FALSE, size = ncell)
data2 = data[index.cell, 1:ngene]

# remove genes with 0 variance
gene.var = apply(data2, 2, var)
var.zero = which(gene.var == 0)
length(var.zero)
```

```{r}
# create the data ready to be analysed
data2 = data2[, setdiff(colnames(data2), names(var.zero))]
dim(data2) # data ready to be input in PCA
```

```{r}
# Check data sparsity
zero_proportion <- sum(data2 == 0) / length(data2)
cat("Zero proportion:", round(zero_proportion * 100, 2), "%\n")
cat("Data class:", class(data2), "\n")
cat("Data dimensions:", nrow(data2), "cells x", ncol(data2), "genes\n")
cat("Non-zero proportion:", round((1 - zero_proportion) * 100, 2), "%\n")
```

# Methods

```{r}
source("R/pca_pSVD.R")

run_pca_full <- function(X, k) {
  mixOmics::pca(X, ncomp = k, center = TRUE, scale = TRUE)
}

run_pca_psvd <- function(X, k) {
  pca_pSVD(X, ncomp = k, center = TRUE, scale = TRUE)
}
```

# Benchmark

```{r}
ks <- c(2, 5, 10, 20)

bench_one <- function(k) {
  if (have_bench) {
    b <- bench::mark(
      pca_full   = { run_pca_full(data2, k) },
      pca_pSVD   = { run_pca_psvd(data2, k) },
      iterations = 1, check = FALSE
    )
    tibble::tibble(
      ncomp = k,
      method = as.character(b$expression),
      time_s = as.numeric(b$median),
      mem    = as.numeric(b$mem_alloc)
    )
  } else {
    t1 <- system.time(run_pca_full(data2, k))["elapsed"]
    t2 <- system.time(run_pca_psvd(data2, k))["elapsed"]
    tibble::tibble(
      ncomp  = k,
      method = c("pca_full","pca_pSVD"),
      time_s = c(t1, t2),
      mem    = NA_real_
    )
  }
}

bench_res <- dplyr::bind_rows(lapply(ks, bench_one))
bench_res

```

```{r}
ggplot(bench_res, aes(ncomp, time_s, group = method, linetype = method)) +
  geom_line() + geom_point() +
  labs(x = "Number of components (k)", y = "Time (s)", linetype = "Method") +
  theme_minimal(base_size = 12)

```

```{r}
speed_tbl <- bench_res |>
  select(ncomp, method, time_s) |>
  pivot_wider(names_from = method, values_from = time_s) |>
  mutate(speedup_pSVD = `pca_full` / `pca_pSVD`) |>
  arrange(ncomp)

kable(speed_tbl, digits = 3, caption = "Runtime & speedups vs full SVD")
```

# Accuracy

```{r}
cmp_one <- function(k) {
  f <- run_pca_full(data2, k)
  p <- run_pca_psvd(data2, k)
  tibble::tibble(
    ncomp = rep(k, 1*k),
    method = rep(c("pca_pSVD"), each = k),
    pc = rep(seq_len(k), times = 1),
    abs_diff = c(abs(f$prop_expl_var$X[1:k] - p$prop_expl_var$X[1:k]))
  )
}

acc_res <- dplyr::bind_rows(lapply(ks, cmp_one))
acc_res %>% group_by(ncomp, method) %>% summarise(max_abs_diff = max(abs_diff), .groups = "drop")

```

```{r}
ggplot(acc_res, aes(pc, abs_diff, color = method, linetype = method)) +
  geom_line() + geom_point(size = 1.6) +
  facet_wrap(~ ncomp, scales = "free_x", ncol = 2) +
  scale_y_continuous(labels = scales::scientific) +
  labs(x = "PC index", y = "Absolute difference in explained variance",
       color = "Method", linetype = "Method",
       title = "Explained-variance differences vs full PCA") +
  theme_minimal(base_size = 12)

```

# Discussion

This dataset doesn't need multilevel analysis because each cell is an **independent sample** from a single snapshot measurement, with no repeated measures, paired design, or nested structure (e.g., multiple timepoints from the same patient).

In pca_pSVD.R, CLR is simplified to `"none"` since it preserves data dimensionality, while ILR is delegated to `mixOmics::pca` because it reduces dimensions (p → p-1) and requires complex contrast matrices that are beyond the scope of this efficient PCA implementation.

-   预期：当 `k ≪ min(n, p)` 时，`pca_pSVD` 的时间显著低于 `pca_full`；解释率差异应在数值容忍范围内。

-   局限：`svds` 为迭代近似；当 `k` 过大或收敛失败时已回退到 `svd`。缺失值/ILR 分支仍由原 `pca()` 处理。

# Session Info

```{r}
sessionInfo()
```
